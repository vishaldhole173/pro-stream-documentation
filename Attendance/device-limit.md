# Limiting Number of Devices for a Breakout

We have introduced a feature to limit the streaming to a maximum number of devices. We leverage the attendance table, sockets & real time communication between UI & Server to achieve this.

* We keep a variable in environment to mark the threshold
```
PLAYBACK_DEVICE_LIMIT=2
```

* We keep track of each active socket in DB through attendance Table's `active_socket_id` column. This column stores the minified socket id that we generate, the actual Web Socket Id (generated by SocketIO) is stored in redis. We can easily retrieve the actual socket id from the minified socket id:

```
const { webSocketId } = await redisService.getSocketInfo(socketId);
```

* When a user joins a breakout, we pull all other unexited attendances, check if their socket is active and collect them into `activePlaybackSessions`.If attendances in `activePlaybackSessions` exceeds `PLAYBACK_DEVICE_LIMIT`, we expel those sessions from Stream & Chat Room using the Socket Ids.

```
async limitPlayBackDevices(breakoutId, userId) {
    const maxDevicesPerUserPerBreakout = process.env.PLAYBACK_DEVICE_LIMIT || 1;
    // Retrieve all Unexited Sessions from DB
    const playbackSessions = (await AttendanceModel.getActiveSessions(breakoutId, userId)) || [];
    const activePlaybackSessions = [];

    // Filter out sessions which have active websocket connection with server
    for (let session of playbackSessions) {
      const socketInfo = await redisService.getSocketInfo(session.active_socket_id);
      const { webSocketId } = socketInfo || {};
      if (webSocketId && isSocketConnected(webSocketId)) {
        activePlaybackSessions.push(session);
      }
    }

    // Limit Devices
    if (activePlaybackSessions.length > maxDevicesPerUserPerBreakout) {
      for (let i = 0; i < activePlaybackSessions.length - maxDevicesPerUserPerBreakout; i++) {
        // activePlaybackSessions.length-maxDevicesPerUserPerBreakout will not send socket message
        // to the most recently joined devices
        const session = activePlaybackSessions[i];
        await this.expelUser(breakoutId, session.active_socket_id);
      }
    }
}
```

```
async expelUser(breakoutId, activeSocketId) {
    const socketId = activeSocketId || this.socketId;
    logger.trace(`expelUser breakoutId = ${breakoutId} socketId = ${socketId}`);
    const { webSocketId } = await redisService.getSocketInfo(socketId);
    if (webSocketId) {
      logger.trace('Sending playback command to: ', webSocketId);
      const socket = getClientSocket(webSocketId);
      socket.emit('playback', 'device-limit-exceeded');
      const roomName = getAudienceChatRoomName(breakoutId);
      socket.leave(roomName);
      await this.recordUserExit(socketId);
    }
}
```

* UI waits for message of session expiry (`device-limit-exceeded`), and upon inception, it redirects the user.

```
this.playbackCommandSubscription = this.socketService
  .onEvent<any>('playback')
  .subscribe((data) => {
    if (data === 'device-limit-exceeded') {
      const title = 'Device Limit Exceeded';
      const message = 'You are viewing stream from new device. You\'ll be redirected shortly.';
      this.toasterService.showError(title, message);
      setTimeout(() => this.appCommonService.navigateTo('/'), 5000);
    }
});
```

![Device Limit Diagram](./images/device-limit-diagram.png)